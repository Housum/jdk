MacOS BSD实现方式.

采用的是KQueue的方式实现,底层还是使用的事件复用的方式


BSD NIO&AIO代码:

JDK KQueue.c:
https://github.com/huangyazhe/openJdk/blob/64729a0d02b190ec2af4b18a4a2730dcad5c6191/jdk/src/solaris/native/sun/nio/ch/KQueue.c

API:
https://blog.csdn.net/Timeinsist/article/details/80978713
https://www.cnblogs.com/FG123/p/5256553.html
https://blog.csdn.net/Namcodream521/article/details/83032615

Port.java
https://github.com/huangyazhe/openJdk/blob/64729a0d02b190ec2af4b18a4a2730dcad5c6191/jdk/src/solaris/classes/sun/nio/ch/Port.java
KQueuePort.java
https://github.com/huangyazhe/openJdk/blob/64729a0d02b190ec2af4b18a4a2730dcad5c6191/jdk/src/solaris/classes/sun/nio/ch/KQueuePort.java

Invoker.java
https://github.com/md-5/OpenJDK/blob/898644be29e5d2c5aaa22860e2d861e73fc4ef63/src/java.base/share/classes/sun/nio/ch/Invoker.java

PendingFuture
https://github.com/md-5/OpenJDK/blob/898644be29e5d2c5aaa22860e2d861e73fc4ef63/src/java.base/share/classes/sun/nio/ch/PendingFuture.java

UnixAsynchronousServerSocketChannelImpl:
https://github.com/huangyazhe/openJdk/blob/64729a0d02b190ec2af4b18a4a2730dcad5c6191/jdk/src/solaris/classes/sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java

2.整体流程
服务端:
创建AsynchronousServerSocketChannel的时候通过openAsynchronousServerSocketChannel创建->在底层实现是通过传入AsynchronousChannelGroup的实现类作为AsynchronousServerSocketChannel的参数创建实例->AsynchronousChannelGroup创建的时候将会创建内核队列(在BSD中是kqueue),并且在多线程中对创建的内核事件进行校验是否有事件被触发了(内部多线程通过协作的方式实现),如果事件被触发的话,那么再回调sun.nio.ch.Port.PollableChannel的onEvent方法(AsynchronousServerSocketChannel实现了接口)->当AsynchronousServerSocketChannel的回调方法onEvent被触发的时候,然后就会做具体的事件,在服务端只做了一件事,那就是创建AsynchronousSocketChannel
创建AsynchronousServerSocketChannel的时候通过openAsynchronousServerSocketChannel创建->在底层实现是通过传入AsynchronousChannelGroup的实现类作为AsynchronousServerSocketChannel的参数创建实例->AsynchronousServerSocketChannel创建的时候,就将该channel对应的文件描述符加入到AsynchronousChannelGroup中的map中 key是文件描述符,value是channel,这样当该fd被触发的时候能够找到channel(在kqueue触发之后,在结构体eventlist上面有触发的文件描述符),其中在创建的时候并没有在事件复用队列上面注册事件,只是创建了socket文件描述符等,在使用accept的时候才正式注册感兴趣的事件->注册事件的职责是在AsynchronousChannelGroup中的，所以调用AsynchronousChannelGroup的方法进行事件的注册
->当事件被触发之后,具体的逻辑将会在Invoker中调用AsynchronousChannelGroup的线程池的线程进行执行逻辑


客服端：
和服务端极其的类似,也是创建AsynchronousSocketChannel以及AsynchronousChannelGroup,同时AsynchronousSocketChannel也实现了sun.nio.ch.Port.PollableChannel接口
只是在客服端的情况下需要操作连接,读,写 这些都是需要注册事件的(服务端只是accept需要注册事件),即时这样,在有事件被触发的时候,还是通过onEvent将AsynchronousSocketChannel被触发的
事件给传到到主流程中处理AsynchronousSocketChannel的onEvent中,onEvent内部对被触发的事件进行判断走不同的处理路径(连接,读,写). 然后对于具体的不同业务逻辑还是通过调用Invoker,Invoker再调用
AsynchronousChannelGroup的线程池的线程进行处理

